.PHONY: help tests tests-coverage build run init-db clean docker-up docker-down docker-clean deps install-tools fmt fmt-check lint dev-setup test-all test-unit schemathesis install-hooks backfill-embeddings prod-up prod-down prod-logs taxonomy-dev

# Default target - show help
help:
	@echo "Available targets:"
	@echo ""
	@echo "Development:"
	@echo "  make dev-setup    - Set up dev environment (postgres, deps, tools, schema, hooks)"
	@echo "  make run          - Run Go API server locally"
	@echo "  make taxonomy-dev - Run Python taxonomy service locally"
	@echo "  make docker-up    - Start dev infrastructure (postgres, pgadmin)"
	@echo "  make docker-down  - Stop dev infrastructure"
	@echo "  make docker-clean - Stop and remove volumes"
	@echo ""
	@echo "Production:"
	@echo "  make prod-up      - Start full stack (postgres, api, taxonomy-generator)"
	@echo "  make prod-down    - Stop full stack"
	@echo "  make prod-logs    - View logs from production stack"
	@echo ""
	@echo "Build & Test:"
	@echo "  make build        - Build API binaries"
	@echo "  make test-unit    - Run unit tests (fast, no database)"
	@echo "  make tests        - Run integration tests"
	@echo "  make test-all     - Run all tests (unit + integration)"
	@echo "  make tests-coverage - Run tests with coverage report"
	@echo "  make schemathesis - Run Schemathesis API tests"
	@echo ""
	@echo "Code Quality:"
	@echo "  make fmt          - Format code with gofumpt"
	@echo "  make fmt-check    - Check if code is formatted"
	@echo "  make lint         - Run linter"
	@echo ""
	@echo "Utilities:"
	@echo "  make init-db      - Initialize database schema"
	@echo "  make backfill-embeddings - Backfill embeddings for existing records"
	@echo "  make deps         - Install Go dependencies"
	@echo "  make install-tools - Install dev tools (gofumpt, golangci-lint)"
	@echo "  make install-hooks - Install git hooks"
	@echo "  make clean        - Clean build artifacts"

# Run all tests (integration tests in tests/ directory)
tests:
	@echo "Running integration tests..."
	go test ./tests/... -v

# Run unit tests (fast, no database required)
test-unit:
	@echo "Running unit tests..."
	go test ./internal/... -v

# Run all tests (unit + integration)
test-all: test-unit tests
	@echo "All tests passed!"

# Run tests with coverage (unit + integration)
tests-coverage:
	@echo "Running tests with coverage..."
	go test ./internal/... ./tests/... -v -cover -coverprofile=coverage.out
	go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# Build the API server
build:
	@echo "Building API server..."
	go build -o bin/api cmd/api/main.go
	go build -o bin/backfill cmd/backfill/main.go
	@echo "Binaries created: bin/api, bin/backfill"

# Backfill embeddings for existing records
# This enqueues River jobs for all records missing embeddings
backfill-embeddings:
	@echo "Backfilling embeddings for existing records..."
	@if [ -f .env ]; then \
		export $$(grep -v '^#' .env | xargs) && \
		go run cmd/backfill/main.go; \
	else \
		go run cmd/backfill/main.go; \
	fi

# Run the API server
run:
	@echo "Checking for .env file..."
	@if [ ! -f .env ]; then \
		echo "Creating .env file with default values..."; \
		echo "# Formbricks Hub Configuration" > .env; \
		echo "# Auto-generated by 'make run' - modify as needed" >> .env; \
		echo "" >> .env; \
		echo "# API Key for authentication (required)" >> .env; \
		echo "API_KEY=test-api-key-12345" >> .env; \
		echo "" >> .env; \
		echo "# Database connection URL" >> .env; \
		echo "DATABASE_URL=postgres://postgres:postgres@localhost:5432/test_db?sslmode=disable" >> .env; \
		echo "" >> .env; \
		echo "# Server port (default: 8080)" >> .env; \
		echo "PORT=8080" >> .env; \
		echo ".env file created with default values."; \
	fi
	@echo "Starting API server..."
	go run cmd/api/main.go

# Initialize database schema
init-db:
	@echo "Initializing database schema..."
	@if [ -f .env ]; then \
		export $$(grep -v '^#' .env | xargs) && \
		if [ -z "$$DATABASE_URL" ]; then \
			echo "Error: DATABASE_URL not found in .env file"; \
			exit 1; \
		fi && \
		for f in sql/*.sql; do \
			echo "Applying $$f..."; \
			psql "$$DATABASE_URL" -f "$$f"; \
		done; \
	else \
		if [ -z "$$DATABASE_URL" ]; then \
			echo "Error: DATABASE_URL environment variable is not set"; \
			echo "Please set it or create a .env file with DATABASE_URL"; \
			exit 1; \
		fi && \
		for f in sql/*.sql; do \
			echo "Applying $$f..."; \
			psql "$$DATABASE_URL" -f "$$f"; \
		done; \
	fi
	@echo "Database schema initialized successfully"


# Start dev infrastructure (postgres, pgadmin)
docker-up:
	@echo "Starting dev infrastructure (postgres, pgadmin)..."
	docker compose up -d
	@echo "Waiting for postgres to be ready..."
	@sleep 3
	@docker compose ps
	@echo ""
	@echo "Postgres: localhost:5432"
	@echo "pgAdmin:  localhost:5050 (admin@formbricks.com / admin)"

# Stop Docker containers
docker-down:
	@echo "Stopping Docker containers..."
	docker compose down

# Stop and remove volumes
docker-clean:
	@echo "Stopping Docker containers and removing volumes..."
	docker compose down -v

# Clean build artifacts
clean:
	@echo "Cleaning build artifacts..."
	rm -rf bin/
	rm -f coverage.out coverage.html
	@echo "Clean complete"

# Install dependencies
deps:
	@echo "Installing dependencies..."
	go mod download
	go mod tidy
	@echo "Dependencies installed"

# Install development tools
# Tool versions - update these periodically
GOFUMPT_VERSION := v0.9.2
GOLANGCI_LINT_VERSION := v2.8.0
GOVULNCHECK_VERSION := v1.1.4

install-tools:
	@echo "Installing development tools..."
	go install mvdan.cc/gofumpt@$(GOFUMPT_VERSION)
	go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@$(GOLANGCI_LINT_VERSION)
	go install golang.org/x/vuln/cmd/govulncheck@$(GOVULNCHECK_VERSION)
	@echo "Tools installed (gofumpt $(GOFUMPT_VERSION), golangci-lint $(GOLANGCI_LINT_VERSION), govulncheck $(GOVULNCHECK_VERSION))"

# Format code
fmt:
	@echo "Formatting code..."
	@command -v gofumpt >/dev/null 2>&1 || { echo "Error: gofumpt not found. Install with: make install-tools"; exit 1; }
	gofumpt -l -w .
	@echo "Code formatted"

# Check code formatting (fails if code needs formatting)
fmt-check:
	@echo "Checking code formatting..."
	@command -v gofumpt >/dev/null 2>&1 || { echo "Error: gofumpt not found. Install with: make install-tools"; exit 1; }
	@if [ -n "$$(gofumpt -l .)" ]; then \
		echo "Error: Code is not formatted. Run 'make fmt' to fix."; \
		gofumpt -l .; \
		exit 1; \
	fi
	@echo "Code is properly formatted"

# Lint code
lint:
	@echo "Linting code..."
	@command -v golangci-lint >/dev/null 2>&1 || { echo "Error: golangci-lint not found. Install with: make install-tools"; exit 1; }
	golangci-lint run ./...

# Install git hooks from .githooks directory
install-hooks:
	@echo "Installing git hooks..."
	@if [ -d .githooks ]; then \
		cp .githooks/pre-commit .git/hooks/pre-commit && \
		chmod +x .git/hooks/pre-commit && \
		echo "✅ Git hooks installed successfully"; \
	else \
		echo "Error: .githooks directory not found"; \
		exit 1; \
	fi

# Run everything needed for development
dev-setup: docker-up deps install-tools init-db install-hooks
	@echo ""
	@echo "Development environment ready!"
	@echo ""
	@echo "Next steps:"
	@echo "  Terminal 1: make run          # Go API on :8080"
	@echo "  Terminal 2: make taxonomy-dev # Python service on :8001 (optional)"

# Run Python taxonomy service locally (uses venv + pip, requires Python 3.11+)
# Prefers python3.11 if available, falls back to python3
TAXONOMY_PYTHON := $(shell command -v python3.11 2>/dev/null || command -v python3 2>/dev/null)

taxonomy-dev:
	@echo "Starting taxonomy-generator service..."
	@$(TAXONOMY_PYTHON) -c "import sys; exit(0 if sys.version_info >= (3, 11) else 1)" 2>/dev/null || \
		{ echo "Error: Python 3.11+ required. Install with: brew install python@3.11"; exit 1; }
	@cd services/taxonomy-generator && \
	if [ ! -f .env ]; then \
		echo "Creating .env from .env.example..."; \
		cp .env.example .env; \
		echo "⚠️  Edit services/taxonomy-generator/.env to set OPENAI_API_KEY"; \
	fi && \
	if [ ! -d .venv ]; then \
		echo "Creating virtual environment..."; \
		$(TAXONOMY_PYTHON) -m venv .venv; \
	fi && \
	. .venv/bin/activate && \
	pip install -q -r requirements.txt && \
	uvicorn src.main:app --reload --port 8001

# Production: start full stack
prod-up:
	@echo "Starting production stack..."
	docker compose -f docker-compose.prod.yml up -d --build
	@echo "Waiting for services..."
	@sleep 5
	@docker compose -f docker-compose.prod.yml ps

# Production: stop full stack
prod-down:
	@echo "Stopping production stack..."
	docker compose -f docker-compose.prod.yml down

# Production: view logs
prod-logs:
	docker compose -f docker-compose.prod.yml logs -f

# Run Schemathesis API tests (all phases for thorough local testing)
# Phases: examples (schema examples), coverage (boundary values), stateful (API sequences), fuzzing (random)
# This runs more thorough tests than CI to find edge-case bugs.
# Requires: API server running (make run in another terminal)
# Requires: uvx (install via: curl -LsSf https://astral.sh/uv/install.sh | sh)
schemathesis:
	@echo "Running Schemathesis API tests (all phases)..."
	@echo "This is deeper testing than CI - may find edge-case bugs."
	@export PATH="$$HOME/.local/bin:$$PATH" && \
	if [ -f .env ]; then \
		export $$(grep -v '^#' .env | xargs) && \
		if [ -z "$$API_KEY" ]; then \
			echo "Warning: API_KEY not found in .env file, tests may fail authentication"; \
		fi && \
		uvx schemathesis run ./openapi.yaml \
			--url http://localhost:8080 \
			--header "Authorization: Bearer $${API_KEY:-test-api-key-12345}" \
			--checks all \
			--phases examples,coverage,stateful,fuzzing \
			--max-examples 50; \
	else \
		if [ -z "$$API_KEY" ]; then \
			echo "Error: API_KEY environment variable is not set and .env file not found"; \
			echo "Please set API_KEY or create a .env file"; \
			exit 1; \
		fi && \
		uvx schemathesis run ./openapi.yaml \
			--url http://localhost:8080 \
			--header "Authorization: Bearer $$API_KEY" \
			--checks all \
			--phases examples,coverage,stateful,fuzzing \
			--max-examples 50; \
	fi
