// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/formbricks/formbricks-rewrite/apps/hub/internal/ent/enrichmentjob"
	"github.com/formbricks/formbricks-rewrite/apps/hub/internal/ent/experiencedata"
	"github.com/formbricks/formbricks-rewrite/apps/hub/internal/ent/predicate"
	"github.com/google/uuid"
	pgvector "github.com/pgvector/pgvector-go"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEnrichmentJob  = "EnrichmentJob"
	TypeExperienceData = "ExperienceData"
)

// EnrichmentJobMutation represents an operation that mutates the EnrichmentJob nodes in the graph.
type EnrichmentJobMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	job_type          *string
	status            *string
	text              *string
	error             *string
	attempts          *int
	addattempts       *int
	created_at        *time.Time
	processed_at      *time.Time
	clearedFields     map[string]struct{}
	experience        *uuid.UUID
	clearedexperience bool
	done              bool
	oldValue          func(context.Context) (*EnrichmentJob, error)
	predicates        []predicate.EnrichmentJob
}

var _ ent.Mutation = (*EnrichmentJobMutation)(nil)

// enrichmentjobOption allows management of the mutation configuration using functional options.
type enrichmentjobOption func(*EnrichmentJobMutation)

// newEnrichmentJobMutation creates new mutation for the EnrichmentJob entity.
func newEnrichmentJobMutation(c config, op Op, opts ...enrichmentjobOption) *EnrichmentJobMutation {
	m := &EnrichmentJobMutation{
		config:        c,
		op:            op,
		typ:           TypeEnrichmentJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnrichmentJobID sets the ID field of the mutation.
func withEnrichmentJobID(id uuid.UUID) enrichmentjobOption {
	return func(m *EnrichmentJobMutation) {
		var (
			err   error
			once  sync.Once
			value *EnrichmentJob
		)
		m.oldValue = func(ctx context.Context) (*EnrichmentJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnrichmentJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnrichmentJob sets the old EnrichmentJob of the mutation.
func withEnrichmentJob(node *EnrichmentJob) enrichmentjobOption {
	return func(m *EnrichmentJobMutation) {
		m.oldValue = func(context.Context) (*EnrichmentJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnrichmentJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnrichmentJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnrichmentJob entities.
func (m *EnrichmentJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnrichmentJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnrichmentJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnrichmentJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExperienceID sets the "experience_id" field.
func (m *EnrichmentJobMutation) SetExperienceID(u uuid.UUID) {
	m.experience = &u
}

// ExperienceID returns the value of the "experience_id" field in the mutation.
func (m *EnrichmentJobMutation) ExperienceID() (r uuid.UUID, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceID returns the old "experience_id" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldExperienceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceID: %w", err)
	}
	return oldValue.ExperienceID, nil
}

// ResetExperienceID resets all changes to the "experience_id" field.
func (m *EnrichmentJobMutation) ResetExperienceID() {
	m.experience = nil
}

// SetJobType sets the "job_type" field.
func (m *EnrichmentJobMutation) SetJobType(s string) {
	m.job_type = &s
}

// JobType returns the value of the "job_type" field in the mutation.
func (m *EnrichmentJobMutation) JobType() (r string, exists bool) {
	v := m.job_type
	if v == nil {
		return
	}
	return *v, true
}

// OldJobType returns the old "job_type" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldJobType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobType: %w", err)
	}
	return oldValue.JobType, nil
}

// ResetJobType resets all changes to the "job_type" field.
func (m *EnrichmentJobMutation) ResetJobType() {
	m.job_type = nil
}

// SetStatus sets the "status" field.
func (m *EnrichmentJobMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EnrichmentJobMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EnrichmentJobMutation) ResetStatus() {
	m.status = nil
}

// SetText sets the "text" field.
func (m *EnrichmentJobMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *EnrichmentJobMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *EnrichmentJobMutation) ResetText() {
	m.text = nil
}

// SetError sets the "error" field.
func (m *EnrichmentJobMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *EnrichmentJobMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *EnrichmentJobMutation) ClearError() {
	m.error = nil
	m.clearedFields[enrichmentjob.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *EnrichmentJobMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[enrichmentjob.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *EnrichmentJobMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, enrichmentjob.FieldError)
}

// SetAttempts sets the "attempts" field.
func (m *EnrichmentJobMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *EnrichmentJobMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *EnrichmentJobMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *EnrichmentJobMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *EnrichmentJobMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnrichmentJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnrichmentJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnrichmentJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *EnrichmentJobMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *EnrichmentJobMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the EnrichmentJob entity.
// If the EnrichmentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrichmentJobMutation) OldProcessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *EnrichmentJobMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[enrichmentjob.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *EnrichmentJobMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[enrichmentjob.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *EnrichmentJobMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, enrichmentjob.FieldProcessedAt)
}

// ClearExperience clears the "experience" edge to the ExperienceData entity.
func (m *EnrichmentJobMutation) ClearExperience() {
	m.clearedexperience = true
	m.clearedFields[enrichmentjob.FieldExperienceID] = struct{}{}
}

// ExperienceCleared reports if the "experience" edge to the ExperienceData entity was cleared.
func (m *EnrichmentJobMutation) ExperienceCleared() bool {
	return m.clearedexperience
}

// ExperienceIDs returns the "experience" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExperienceID instead. It exists only for internal usage by the builders.
func (m *EnrichmentJobMutation) ExperienceIDs() (ids []uuid.UUID) {
	if id := m.experience; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExperience resets all changes to the "experience" edge.
func (m *EnrichmentJobMutation) ResetExperience() {
	m.experience = nil
	m.clearedexperience = false
}

// Where appends a list predicates to the EnrichmentJobMutation builder.
func (m *EnrichmentJobMutation) Where(ps ...predicate.EnrichmentJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnrichmentJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnrichmentJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnrichmentJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnrichmentJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnrichmentJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnrichmentJob).
func (m *EnrichmentJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnrichmentJobMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.experience != nil {
		fields = append(fields, enrichmentjob.FieldExperienceID)
	}
	if m.job_type != nil {
		fields = append(fields, enrichmentjob.FieldJobType)
	}
	if m.status != nil {
		fields = append(fields, enrichmentjob.FieldStatus)
	}
	if m.text != nil {
		fields = append(fields, enrichmentjob.FieldText)
	}
	if m.error != nil {
		fields = append(fields, enrichmentjob.FieldError)
	}
	if m.attempts != nil {
		fields = append(fields, enrichmentjob.FieldAttempts)
	}
	if m.created_at != nil {
		fields = append(fields, enrichmentjob.FieldCreatedAt)
	}
	if m.processed_at != nil {
		fields = append(fields, enrichmentjob.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnrichmentJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enrichmentjob.FieldExperienceID:
		return m.ExperienceID()
	case enrichmentjob.FieldJobType:
		return m.JobType()
	case enrichmentjob.FieldStatus:
		return m.Status()
	case enrichmentjob.FieldText:
		return m.Text()
	case enrichmentjob.FieldError:
		return m.Error()
	case enrichmentjob.FieldAttempts:
		return m.Attempts()
	case enrichmentjob.FieldCreatedAt:
		return m.CreatedAt()
	case enrichmentjob.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnrichmentJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enrichmentjob.FieldExperienceID:
		return m.OldExperienceID(ctx)
	case enrichmentjob.FieldJobType:
		return m.OldJobType(ctx)
	case enrichmentjob.FieldStatus:
		return m.OldStatus(ctx)
	case enrichmentjob.FieldText:
		return m.OldText(ctx)
	case enrichmentjob.FieldError:
		return m.OldError(ctx)
	case enrichmentjob.FieldAttempts:
		return m.OldAttempts(ctx)
	case enrichmentjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enrichmentjob.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EnrichmentJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrichmentJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enrichmentjob.FieldExperienceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceID(v)
		return nil
	case enrichmentjob.FieldJobType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobType(v)
		return nil
	case enrichmentjob.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case enrichmentjob.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case enrichmentjob.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case enrichmentjob.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case enrichmentjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enrichmentjob.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnrichmentJobMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, enrichmentjob.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnrichmentJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enrichmentjob.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrichmentJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enrichmentjob.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnrichmentJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enrichmentjob.FieldError) {
		fields = append(fields, enrichmentjob.FieldError)
	}
	if m.FieldCleared(enrichmentjob.FieldProcessedAt) {
		fields = append(fields, enrichmentjob.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnrichmentJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnrichmentJobMutation) ClearField(name string) error {
	switch name {
	case enrichmentjob.FieldError:
		m.ClearError()
		return nil
	case enrichmentjob.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnrichmentJobMutation) ResetField(name string) error {
	switch name {
	case enrichmentjob.FieldExperienceID:
		m.ResetExperienceID()
		return nil
	case enrichmentjob.FieldJobType:
		m.ResetJobType()
		return nil
	case enrichmentjob.FieldStatus:
		m.ResetStatus()
		return nil
	case enrichmentjob.FieldText:
		m.ResetText()
		return nil
	case enrichmentjob.FieldError:
		m.ResetError()
		return nil
	case enrichmentjob.FieldAttempts:
		m.ResetAttempts()
		return nil
	case enrichmentjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enrichmentjob.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnrichmentJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.experience != nil {
		edges = append(edges, enrichmentjob.EdgeExperience)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnrichmentJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enrichmentjob.EdgeExperience:
		if id := m.experience; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnrichmentJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnrichmentJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnrichmentJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexperience {
		edges = append(edges, enrichmentjob.EdgeExperience)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnrichmentJobMutation) EdgeCleared(name string) bool {
	switch name {
	case enrichmentjob.EdgeExperience:
		return m.clearedexperience
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnrichmentJobMutation) ClearEdge(name string) error {
	switch name {
	case enrichmentjob.EdgeExperience:
		m.ClearExperience()
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnrichmentJobMutation) ResetEdge(name string) error {
	switch name {
	case enrichmentjob.EdgeExperience:
		m.ResetExperience()
		return nil
	}
	return fmt.Errorf("unknown EnrichmentJob edge %s", name)
}

// ExperienceDataMutation represents an operation that mutates the ExperienceData nodes in the graph.
type ExperienceDataMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	collected_at       *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	source_type        *string
	source_id          *string
	source_name        *string
	field_id           *string
	field_label        *string
	field_type         *string
	value_text         *string
	value_number       *float64
	addvalue_number    *float64
	value_boolean      *bool
	value_date         *time.Time
	value_json         *map[string]interface{}
	metadata           *map[string]interface{}
	language           *string
	sentiment          *string
	sentiment_score    *float64
	addsentiment_score *float64
	emotion            *string
	topics             *[]string
	appendtopics       []string
	user_identifier    *string
	embedding          *pgvector.Vector
	embedding_model    *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ExperienceData, error)
	predicates         []predicate.ExperienceData
}

var _ ent.Mutation = (*ExperienceDataMutation)(nil)

// experiencedataOption allows management of the mutation configuration using functional options.
type experiencedataOption func(*ExperienceDataMutation)

// newExperienceDataMutation creates new mutation for the ExperienceData entity.
func newExperienceDataMutation(c config, op Op, opts ...experiencedataOption) *ExperienceDataMutation {
	m := &ExperienceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeExperienceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExperienceDataID sets the ID field of the mutation.
func withExperienceDataID(id uuid.UUID) experiencedataOption {
	return func(m *ExperienceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ExperienceData
		)
		m.oldValue = func(ctx context.Context) (*ExperienceData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExperienceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExperienceData sets the old ExperienceData of the mutation.
func withExperienceData(node *ExperienceData) experiencedataOption {
	return func(m *ExperienceDataMutation) {
		m.oldValue = func(context.Context) (*ExperienceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExperienceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExperienceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExperienceData entities.
func (m *ExperienceDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExperienceDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExperienceDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExperienceData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCollectedAt sets the "collected_at" field.
func (m *ExperienceDataMutation) SetCollectedAt(t time.Time) {
	m.collected_at = &t
}

// CollectedAt returns the value of the "collected_at" field in the mutation.
func (m *ExperienceDataMutation) CollectedAt() (r time.Time, exists bool) {
	v := m.collected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedAt returns the old "collected_at" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldCollectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedAt: %w", err)
	}
	return oldValue.CollectedAt, nil
}

// ResetCollectedAt resets all changes to the "collected_at" field.
func (m *ExperienceDataMutation) ResetCollectedAt() {
	m.collected_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExperienceDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExperienceDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExperienceDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExperienceDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExperienceDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExperienceDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSourceType sets the "source_type" field.
func (m *ExperienceDataMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ExperienceDataMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ExperienceDataMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSourceID sets the "source_id" field.
func (m *ExperienceDataMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *ExperienceDataMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *ExperienceDataMutation) ClearSourceID() {
	m.source_id = nil
	m.clearedFields[experiencedata.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *ExperienceDataMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *ExperienceDataMutation) ResetSourceID() {
	m.source_id = nil
	delete(m.clearedFields, experiencedata.FieldSourceID)
}

// SetSourceName sets the "source_name" field.
func (m *ExperienceDataMutation) SetSourceName(s string) {
	m.source_name = &s
}

// SourceName returns the value of the "source_name" field in the mutation.
func (m *ExperienceDataMutation) SourceName() (r string, exists bool) {
	v := m.source_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceName returns the old "source_name" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldSourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceName: %w", err)
	}
	return oldValue.SourceName, nil
}

// ClearSourceName clears the value of the "source_name" field.
func (m *ExperienceDataMutation) ClearSourceName() {
	m.source_name = nil
	m.clearedFields[experiencedata.FieldSourceName] = struct{}{}
}

// SourceNameCleared returns if the "source_name" field was cleared in this mutation.
func (m *ExperienceDataMutation) SourceNameCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldSourceName]
	return ok
}

// ResetSourceName resets all changes to the "source_name" field.
func (m *ExperienceDataMutation) ResetSourceName() {
	m.source_name = nil
	delete(m.clearedFields, experiencedata.FieldSourceName)
}

// SetFieldID sets the "field_id" field.
func (m *ExperienceDataMutation) SetFieldID(s string) {
	m.field_id = &s
}

// FieldID returns the value of the "field_id" field in the mutation.
func (m *ExperienceDataMutation) FieldID() (r string, exists bool) {
	v := m.field_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldID returns the old "field_id" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldFieldID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldID: %w", err)
	}
	return oldValue.FieldID, nil
}

// ResetFieldID resets all changes to the "field_id" field.
func (m *ExperienceDataMutation) ResetFieldID() {
	m.field_id = nil
}

// SetFieldLabel sets the "field_label" field.
func (m *ExperienceDataMutation) SetFieldLabel(s string) {
	m.field_label = &s
}

// FieldLabel returns the value of the "field_label" field in the mutation.
func (m *ExperienceDataMutation) FieldLabel() (r string, exists bool) {
	v := m.field_label
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldLabel returns the old "field_label" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldFieldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldLabel: %w", err)
	}
	return oldValue.FieldLabel, nil
}

// ClearFieldLabel clears the value of the "field_label" field.
func (m *ExperienceDataMutation) ClearFieldLabel() {
	m.field_label = nil
	m.clearedFields[experiencedata.FieldFieldLabel] = struct{}{}
}

// FieldLabelCleared returns if the "field_label" field was cleared in this mutation.
func (m *ExperienceDataMutation) FieldLabelCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldFieldLabel]
	return ok
}

// ResetFieldLabel resets all changes to the "field_label" field.
func (m *ExperienceDataMutation) ResetFieldLabel() {
	m.field_label = nil
	delete(m.clearedFields, experiencedata.FieldFieldLabel)
}

// SetFieldType sets the "field_type" field.
func (m *ExperienceDataMutation) SetFieldType(s string) {
	m.field_type = &s
}

// FieldType returns the value of the "field_type" field in the mutation.
func (m *ExperienceDataMutation) FieldType() (r string, exists bool) {
	v := m.field_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldType returns the old "field_type" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldFieldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldType: %w", err)
	}
	return oldValue.FieldType, nil
}

// ResetFieldType resets all changes to the "field_type" field.
func (m *ExperienceDataMutation) ResetFieldType() {
	m.field_type = nil
}

// SetValueText sets the "value_text" field.
func (m *ExperienceDataMutation) SetValueText(s string) {
	m.value_text = &s
}

// ValueText returns the value of the "value_text" field in the mutation.
func (m *ExperienceDataMutation) ValueText() (r string, exists bool) {
	v := m.value_text
	if v == nil {
		return
	}
	return *v, true
}

// OldValueText returns the old "value_text" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldValueText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueText: %w", err)
	}
	return oldValue.ValueText, nil
}

// ClearValueText clears the value of the "value_text" field.
func (m *ExperienceDataMutation) ClearValueText() {
	m.value_text = nil
	m.clearedFields[experiencedata.FieldValueText] = struct{}{}
}

// ValueTextCleared returns if the "value_text" field was cleared in this mutation.
func (m *ExperienceDataMutation) ValueTextCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldValueText]
	return ok
}

// ResetValueText resets all changes to the "value_text" field.
func (m *ExperienceDataMutation) ResetValueText() {
	m.value_text = nil
	delete(m.clearedFields, experiencedata.FieldValueText)
}

// SetValueNumber sets the "value_number" field.
func (m *ExperienceDataMutation) SetValueNumber(f float64) {
	m.value_number = &f
	m.addvalue_number = nil
}

// ValueNumber returns the value of the "value_number" field in the mutation.
func (m *ExperienceDataMutation) ValueNumber() (r float64, exists bool) {
	v := m.value_number
	if v == nil {
		return
	}
	return *v, true
}

// OldValueNumber returns the old "value_number" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldValueNumber(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueNumber: %w", err)
	}
	return oldValue.ValueNumber, nil
}

// AddValueNumber adds f to the "value_number" field.
func (m *ExperienceDataMutation) AddValueNumber(f float64) {
	if m.addvalue_number != nil {
		*m.addvalue_number += f
	} else {
		m.addvalue_number = &f
	}
}

// AddedValueNumber returns the value that was added to the "value_number" field in this mutation.
func (m *ExperienceDataMutation) AddedValueNumber() (r float64, exists bool) {
	v := m.addvalue_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearValueNumber clears the value of the "value_number" field.
func (m *ExperienceDataMutation) ClearValueNumber() {
	m.value_number = nil
	m.addvalue_number = nil
	m.clearedFields[experiencedata.FieldValueNumber] = struct{}{}
}

// ValueNumberCleared returns if the "value_number" field was cleared in this mutation.
func (m *ExperienceDataMutation) ValueNumberCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldValueNumber]
	return ok
}

// ResetValueNumber resets all changes to the "value_number" field.
func (m *ExperienceDataMutation) ResetValueNumber() {
	m.value_number = nil
	m.addvalue_number = nil
	delete(m.clearedFields, experiencedata.FieldValueNumber)
}

// SetValueBoolean sets the "value_boolean" field.
func (m *ExperienceDataMutation) SetValueBoolean(b bool) {
	m.value_boolean = &b
}

// ValueBoolean returns the value of the "value_boolean" field in the mutation.
func (m *ExperienceDataMutation) ValueBoolean() (r bool, exists bool) {
	v := m.value_boolean
	if v == nil {
		return
	}
	return *v, true
}

// OldValueBoolean returns the old "value_boolean" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldValueBoolean(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueBoolean is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueBoolean requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueBoolean: %w", err)
	}
	return oldValue.ValueBoolean, nil
}

// ClearValueBoolean clears the value of the "value_boolean" field.
func (m *ExperienceDataMutation) ClearValueBoolean() {
	m.value_boolean = nil
	m.clearedFields[experiencedata.FieldValueBoolean] = struct{}{}
}

// ValueBooleanCleared returns if the "value_boolean" field was cleared in this mutation.
func (m *ExperienceDataMutation) ValueBooleanCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldValueBoolean]
	return ok
}

// ResetValueBoolean resets all changes to the "value_boolean" field.
func (m *ExperienceDataMutation) ResetValueBoolean() {
	m.value_boolean = nil
	delete(m.clearedFields, experiencedata.FieldValueBoolean)
}

// SetValueDate sets the "value_date" field.
func (m *ExperienceDataMutation) SetValueDate(t time.Time) {
	m.value_date = &t
}

// ValueDate returns the value of the "value_date" field in the mutation.
func (m *ExperienceDataMutation) ValueDate() (r time.Time, exists bool) {
	v := m.value_date
	if v == nil {
		return
	}
	return *v, true
}

// OldValueDate returns the old "value_date" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldValueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueDate: %w", err)
	}
	return oldValue.ValueDate, nil
}

// ClearValueDate clears the value of the "value_date" field.
func (m *ExperienceDataMutation) ClearValueDate() {
	m.value_date = nil
	m.clearedFields[experiencedata.FieldValueDate] = struct{}{}
}

// ValueDateCleared returns if the "value_date" field was cleared in this mutation.
func (m *ExperienceDataMutation) ValueDateCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldValueDate]
	return ok
}

// ResetValueDate resets all changes to the "value_date" field.
func (m *ExperienceDataMutation) ResetValueDate() {
	m.value_date = nil
	delete(m.clearedFields, experiencedata.FieldValueDate)
}

// SetValueJSON sets the "value_json" field.
func (m *ExperienceDataMutation) SetValueJSON(value map[string]interface{}) {
	m.value_json = &value
}

// ValueJSON returns the value of the "value_json" field in the mutation.
func (m *ExperienceDataMutation) ValueJSON() (r map[string]interface{}, exists bool) {
	v := m.value_json
	if v == nil {
		return
	}
	return *v, true
}

// OldValueJSON returns the old "value_json" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldValueJSON(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueJSON: %w", err)
	}
	return oldValue.ValueJSON, nil
}

// ClearValueJSON clears the value of the "value_json" field.
func (m *ExperienceDataMutation) ClearValueJSON() {
	m.value_json = nil
	m.clearedFields[experiencedata.FieldValueJSON] = struct{}{}
}

// ValueJSONCleared returns if the "value_json" field was cleared in this mutation.
func (m *ExperienceDataMutation) ValueJSONCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldValueJSON]
	return ok
}

// ResetValueJSON resets all changes to the "value_json" field.
func (m *ExperienceDataMutation) ResetValueJSON() {
	m.value_json = nil
	delete(m.clearedFields, experiencedata.FieldValueJSON)
}

// SetMetadata sets the "metadata" field.
func (m *ExperienceDataMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ExperienceDataMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ExperienceDataMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[experiencedata.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ExperienceDataMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ExperienceDataMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, experiencedata.FieldMetadata)
}

// SetLanguage sets the "language" field.
func (m *ExperienceDataMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *ExperienceDataMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *ExperienceDataMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[experiencedata.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *ExperienceDataMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *ExperienceDataMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, experiencedata.FieldLanguage)
}

// SetSentiment sets the "sentiment" field.
func (m *ExperienceDataMutation) SetSentiment(s string) {
	m.sentiment = &s
}

// Sentiment returns the value of the "sentiment" field in the mutation.
func (m *ExperienceDataMutation) Sentiment() (r string, exists bool) {
	v := m.sentiment
	if v == nil {
		return
	}
	return *v, true
}

// OldSentiment returns the old "sentiment" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldSentiment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentiment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentiment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentiment: %w", err)
	}
	return oldValue.Sentiment, nil
}

// ClearSentiment clears the value of the "sentiment" field.
func (m *ExperienceDataMutation) ClearSentiment() {
	m.sentiment = nil
	m.clearedFields[experiencedata.FieldSentiment] = struct{}{}
}

// SentimentCleared returns if the "sentiment" field was cleared in this mutation.
func (m *ExperienceDataMutation) SentimentCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldSentiment]
	return ok
}

// ResetSentiment resets all changes to the "sentiment" field.
func (m *ExperienceDataMutation) ResetSentiment() {
	m.sentiment = nil
	delete(m.clearedFields, experiencedata.FieldSentiment)
}

// SetSentimentScore sets the "sentiment_score" field.
func (m *ExperienceDataMutation) SetSentimentScore(f float64) {
	m.sentiment_score = &f
	m.addsentiment_score = nil
}

// SentimentScore returns the value of the "sentiment_score" field in the mutation.
func (m *ExperienceDataMutation) SentimentScore() (r float64, exists bool) {
	v := m.sentiment_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSentimentScore returns the old "sentiment_score" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldSentimentScore(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentimentScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentimentScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentimentScore: %w", err)
	}
	return oldValue.SentimentScore, nil
}

// AddSentimentScore adds f to the "sentiment_score" field.
func (m *ExperienceDataMutation) AddSentimentScore(f float64) {
	if m.addsentiment_score != nil {
		*m.addsentiment_score += f
	} else {
		m.addsentiment_score = &f
	}
}

// AddedSentimentScore returns the value that was added to the "sentiment_score" field in this mutation.
func (m *ExperienceDataMutation) AddedSentimentScore() (r float64, exists bool) {
	v := m.addsentiment_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearSentimentScore clears the value of the "sentiment_score" field.
func (m *ExperienceDataMutation) ClearSentimentScore() {
	m.sentiment_score = nil
	m.addsentiment_score = nil
	m.clearedFields[experiencedata.FieldSentimentScore] = struct{}{}
}

// SentimentScoreCleared returns if the "sentiment_score" field was cleared in this mutation.
func (m *ExperienceDataMutation) SentimentScoreCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldSentimentScore]
	return ok
}

// ResetSentimentScore resets all changes to the "sentiment_score" field.
func (m *ExperienceDataMutation) ResetSentimentScore() {
	m.sentiment_score = nil
	m.addsentiment_score = nil
	delete(m.clearedFields, experiencedata.FieldSentimentScore)
}

// SetEmotion sets the "emotion" field.
func (m *ExperienceDataMutation) SetEmotion(s string) {
	m.emotion = &s
}

// Emotion returns the value of the "emotion" field in the mutation.
func (m *ExperienceDataMutation) Emotion() (r string, exists bool) {
	v := m.emotion
	if v == nil {
		return
	}
	return *v, true
}

// OldEmotion returns the old "emotion" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldEmotion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmotion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmotion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmotion: %w", err)
	}
	return oldValue.Emotion, nil
}

// ClearEmotion clears the value of the "emotion" field.
func (m *ExperienceDataMutation) ClearEmotion() {
	m.emotion = nil
	m.clearedFields[experiencedata.FieldEmotion] = struct{}{}
}

// EmotionCleared returns if the "emotion" field was cleared in this mutation.
func (m *ExperienceDataMutation) EmotionCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldEmotion]
	return ok
}

// ResetEmotion resets all changes to the "emotion" field.
func (m *ExperienceDataMutation) ResetEmotion() {
	m.emotion = nil
	delete(m.clearedFields, experiencedata.FieldEmotion)
}

// SetTopics sets the "topics" field.
func (m *ExperienceDataMutation) SetTopics(s []string) {
	m.topics = &s
	m.appendtopics = nil
}

// Topics returns the value of the "topics" field in the mutation.
func (m *ExperienceDataMutation) Topics() (r []string, exists bool) {
	v := m.topics
	if v == nil {
		return
	}
	return *v, true
}

// OldTopics returns the old "topics" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldTopics(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopics: %w", err)
	}
	return oldValue.Topics, nil
}

// AppendTopics adds s to the "topics" field.
func (m *ExperienceDataMutation) AppendTopics(s []string) {
	m.appendtopics = append(m.appendtopics, s...)
}

// AppendedTopics returns the list of values that were appended to the "topics" field in this mutation.
func (m *ExperienceDataMutation) AppendedTopics() ([]string, bool) {
	if len(m.appendtopics) == 0 {
		return nil, false
	}
	return m.appendtopics, true
}

// ClearTopics clears the value of the "topics" field.
func (m *ExperienceDataMutation) ClearTopics() {
	m.topics = nil
	m.appendtopics = nil
	m.clearedFields[experiencedata.FieldTopics] = struct{}{}
}

// TopicsCleared returns if the "topics" field was cleared in this mutation.
func (m *ExperienceDataMutation) TopicsCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldTopics]
	return ok
}

// ResetTopics resets all changes to the "topics" field.
func (m *ExperienceDataMutation) ResetTopics() {
	m.topics = nil
	m.appendtopics = nil
	delete(m.clearedFields, experiencedata.FieldTopics)
}

// SetUserIdentifier sets the "user_identifier" field.
func (m *ExperienceDataMutation) SetUserIdentifier(s string) {
	m.user_identifier = &s
}

// UserIdentifier returns the value of the "user_identifier" field in the mutation.
func (m *ExperienceDataMutation) UserIdentifier() (r string, exists bool) {
	v := m.user_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentifier returns the old "user_identifier" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldUserIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentifier: %w", err)
	}
	return oldValue.UserIdentifier, nil
}

// ClearUserIdentifier clears the value of the "user_identifier" field.
func (m *ExperienceDataMutation) ClearUserIdentifier() {
	m.user_identifier = nil
	m.clearedFields[experiencedata.FieldUserIdentifier] = struct{}{}
}

// UserIdentifierCleared returns if the "user_identifier" field was cleared in this mutation.
func (m *ExperienceDataMutation) UserIdentifierCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldUserIdentifier]
	return ok
}

// ResetUserIdentifier resets all changes to the "user_identifier" field.
func (m *ExperienceDataMutation) ResetUserIdentifier() {
	m.user_identifier = nil
	delete(m.clearedFields, experiencedata.FieldUserIdentifier)
}

// SetEmbedding sets the "embedding" field.
func (m *ExperienceDataMutation) SetEmbedding(pg pgvector.Vector) {
	m.embedding = &pg
}

// Embedding returns the value of the "embedding" field in the mutation.
func (m *ExperienceDataMutation) Embedding() (r pgvector.Vector, exists bool) {
	v := m.embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbedding returns the old "embedding" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldEmbedding(ctx context.Context) (v *pgvector.Vector, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbedding: %w", err)
	}
	return oldValue.Embedding, nil
}

// ClearEmbedding clears the value of the "embedding" field.
func (m *ExperienceDataMutation) ClearEmbedding() {
	m.embedding = nil
	m.clearedFields[experiencedata.FieldEmbedding] = struct{}{}
}

// EmbeddingCleared returns if the "embedding" field was cleared in this mutation.
func (m *ExperienceDataMutation) EmbeddingCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldEmbedding]
	return ok
}

// ResetEmbedding resets all changes to the "embedding" field.
func (m *ExperienceDataMutation) ResetEmbedding() {
	m.embedding = nil
	delete(m.clearedFields, experiencedata.FieldEmbedding)
}

// SetEmbeddingModel sets the "embedding_model" field.
func (m *ExperienceDataMutation) SetEmbeddingModel(s string) {
	m.embedding_model = &s
}

// EmbeddingModel returns the value of the "embedding_model" field in the mutation.
func (m *ExperienceDataMutation) EmbeddingModel() (r string, exists bool) {
	v := m.embedding_model
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbeddingModel returns the old "embedding_model" field's value of the ExperienceData entity.
// If the ExperienceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceDataMutation) OldEmbeddingModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbeddingModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbeddingModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbeddingModel: %w", err)
	}
	return oldValue.EmbeddingModel, nil
}

// ClearEmbeddingModel clears the value of the "embedding_model" field.
func (m *ExperienceDataMutation) ClearEmbeddingModel() {
	m.embedding_model = nil
	m.clearedFields[experiencedata.FieldEmbeddingModel] = struct{}{}
}

// EmbeddingModelCleared returns if the "embedding_model" field was cleared in this mutation.
func (m *ExperienceDataMutation) EmbeddingModelCleared() bool {
	_, ok := m.clearedFields[experiencedata.FieldEmbeddingModel]
	return ok
}

// ResetEmbeddingModel resets all changes to the "embedding_model" field.
func (m *ExperienceDataMutation) ResetEmbeddingModel() {
	m.embedding_model = nil
	delete(m.clearedFields, experiencedata.FieldEmbeddingModel)
}

// Where appends a list predicates to the ExperienceDataMutation builder.
func (m *ExperienceDataMutation) Where(ps ...predicate.ExperienceData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExperienceDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExperienceDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExperienceData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExperienceDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExperienceDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExperienceData).
func (m *ExperienceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExperienceDataMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.collected_at != nil {
		fields = append(fields, experiencedata.FieldCollectedAt)
	}
	if m.created_at != nil {
		fields = append(fields, experiencedata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, experiencedata.FieldUpdatedAt)
	}
	if m.source_type != nil {
		fields = append(fields, experiencedata.FieldSourceType)
	}
	if m.source_id != nil {
		fields = append(fields, experiencedata.FieldSourceID)
	}
	if m.source_name != nil {
		fields = append(fields, experiencedata.FieldSourceName)
	}
	if m.field_id != nil {
		fields = append(fields, experiencedata.FieldFieldID)
	}
	if m.field_label != nil {
		fields = append(fields, experiencedata.FieldFieldLabel)
	}
	if m.field_type != nil {
		fields = append(fields, experiencedata.FieldFieldType)
	}
	if m.value_text != nil {
		fields = append(fields, experiencedata.FieldValueText)
	}
	if m.value_number != nil {
		fields = append(fields, experiencedata.FieldValueNumber)
	}
	if m.value_boolean != nil {
		fields = append(fields, experiencedata.FieldValueBoolean)
	}
	if m.value_date != nil {
		fields = append(fields, experiencedata.FieldValueDate)
	}
	if m.value_json != nil {
		fields = append(fields, experiencedata.FieldValueJSON)
	}
	if m.metadata != nil {
		fields = append(fields, experiencedata.FieldMetadata)
	}
	if m.language != nil {
		fields = append(fields, experiencedata.FieldLanguage)
	}
	if m.sentiment != nil {
		fields = append(fields, experiencedata.FieldSentiment)
	}
	if m.sentiment_score != nil {
		fields = append(fields, experiencedata.FieldSentimentScore)
	}
	if m.emotion != nil {
		fields = append(fields, experiencedata.FieldEmotion)
	}
	if m.topics != nil {
		fields = append(fields, experiencedata.FieldTopics)
	}
	if m.user_identifier != nil {
		fields = append(fields, experiencedata.FieldUserIdentifier)
	}
	if m.embedding != nil {
		fields = append(fields, experiencedata.FieldEmbedding)
	}
	if m.embedding_model != nil {
		fields = append(fields, experiencedata.FieldEmbeddingModel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExperienceDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case experiencedata.FieldCollectedAt:
		return m.CollectedAt()
	case experiencedata.FieldCreatedAt:
		return m.CreatedAt()
	case experiencedata.FieldUpdatedAt:
		return m.UpdatedAt()
	case experiencedata.FieldSourceType:
		return m.SourceType()
	case experiencedata.FieldSourceID:
		return m.SourceID()
	case experiencedata.FieldSourceName:
		return m.SourceName()
	case experiencedata.FieldFieldID:
		return m.FieldID()
	case experiencedata.FieldFieldLabel:
		return m.FieldLabel()
	case experiencedata.FieldFieldType:
		return m.FieldType()
	case experiencedata.FieldValueText:
		return m.ValueText()
	case experiencedata.FieldValueNumber:
		return m.ValueNumber()
	case experiencedata.FieldValueBoolean:
		return m.ValueBoolean()
	case experiencedata.FieldValueDate:
		return m.ValueDate()
	case experiencedata.FieldValueJSON:
		return m.ValueJSON()
	case experiencedata.FieldMetadata:
		return m.Metadata()
	case experiencedata.FieldLanguage:
		return m.Language()
	case experiencedata.FieldSentiment:
		return m.Sentiment()
	case experiencedata.FieldSentimentScore:
		return m.SentimentScore()
	case experiencedata.FieldEmotion:
		return m.Emotion()
	case experiencedata.FieldTopics:
		return m.Topics()
	case experiencedata.FieldUserIdentifier:
		return m.UserIdentifier()
	case experiencedata.FieldEmbedding:
		return m.Embedding()
	case experiencedata.FieldEmbeddingModel:
		return m.EmbeddingModel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExperienceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case experiencedata.FieldCollectedAt:
		return m.OldCollectedAt(ctx)
	case experiencedata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case experiencedata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case experiencedata.FieldSourceType:
		return m.OldSourceType(ctx)
	case experiencedata.FieldSourceID:
		return m.OldSourceID(ctx)
	case experiencedata.FieldSourceName:
		return m.OldSourceName(ctx)
	case experiencedata.FieldFieldID:
		return m.OldFieldID(ctx)
	case experiencedata.FieldFieldLabel:
		return m.OldFieldLabel(ctx)
	case experiencedata.FieldFieldType:
		return m.OldFieldType(ctx)
	case experiencedata.FieldValueText:
		return m.OldValueText(ctx)
	case experiencedata.FieldValueNumber:
		return m.OldValueNumber(ctx)
	case experiencedata.FieldValueBoolean:
		return m.OldValueBoolean(ctx)
	case experiencedata.FieldValueDate:
		return m.OldValueDate(ctx)
	case experiencedata.FieldValueJSON:
		return m.OldValueJSON(ctx)
	case experiencedata.FieldMetadata:
		return m.OldMetadata(ctx)
	case experiencedata.FieldLanguage:
		return m.OldLanguage(ctx)
	case experiencedata.FieldSentiment:
		return m.OldSentiment(ctx)
	case experiencedata.FieldSentimentScore:
		return m.OldSentimentScore(ctx)
	case experiencedata.FieldEmotion:
		return m.OldEmotion(ctx)
	case experiencedata.FieldTopics:
		return m.OldTopics(ctx)
	case experiencedata.FieldUserIdentifier:
		return m.OldUserIdentifier(ctx)
	case experiencedata.FieldEmbedding:
		return m.OldEmbedding(ctx)
	case experiencedata.FieldEmbeddingModel:
		return m.OldEmbeddingModel(ctx)
	}
	return nil, fmt.Errorf("unknown ExperienceData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case experiencedata.FieldCollectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedAt(v)
		return nil
	case experiencedata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case experiencedata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case experiencedata.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case experiencedata.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case experiencedata.FieldSourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceName(v)
		return nil
	case experiencedata.FieldFieldID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldID(v)
		return nil
	case experiencedata.FieldFieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldLabel(v)
		return nil
	case experiencedata.FieldFieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldType(v)
		return nil
	case experiencedata.FieldValueText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueText(v)
		return nil
	case experiencedata.FieldValueNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueNumber(v)
		return nil
	case experiencedata.FieldValueBoolean:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueBoolean(v)
		return nil
	case experiencedata.FieldValueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueDate(v)
		return nil
	case experiencedata.FieldValueJSON:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueJSON(v)
		return nil
	case experiencedata.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case experiencedata.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case experiencedata.FieldSentiment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentiment(v)
		return nil
	case experiencedata.FieldSentimentScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentimentScore(v)
		return nil
	case experiencedata.FieldEmotion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmotion(v)
		return nil
	case experiencedata.FieldTopics:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopics(v)
		return nil
	case experiencedata.FieldUserIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentifier(v)
		return nil
	case experiencedata.FieldEmbedding:
		v, ok := value.(pgvector.Vector)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbedding(v)
		return nil
	case experiencedata.FieldEmbeddingModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbeddingModel(v)
		return nil
	}
	return fmt.Errorf("unknown ExperienceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExperienceDataMutation) AddedFields() []string {
	var fields []string
	if m.addvalue_number != nil {
		fields = append(fields, experiencedata.FieldValueNumber)
	}
	if m.addsentiment_score != nil {
		fields = append(fields, experiencedata.FieldSentimentScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExperienceDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case experiencedata.FieldValueNumber:
		return m.AddedValueNumber()
	case experiencedata.FieldSentimentScore:
		return m.AddedSentimentScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case experiencedata.FieldValueNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValueNumber(v)
		return nil
	case experiencedata.FieldSentimentScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentimentScore(v)
		return nil
	}
	return fmt.Errorf("unknown ExperienceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExperienceDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(experiencedata.FieldSourceID) {
		fields = append(fields, experiencedata.FieldSourceID)
	}
	if m.FieldCleared(experiencedata.FieldSourceName) {
		fields = append(fields, experiencedata.FieldSourceName)
	}
	if m.FieldCleared(experiencedata.FieldFieldLabel) {
		fields = append(fields, experiencedata.FieldFieldLabel)
	}
	if m.FieldCleared(experiencedata.FieldValueText) {
		fields = append(fields, experiencedata.FieldValueText)
	}
	if m.FieldCleared(experiencedata.FieldValueNumber) {
		fields = append(fields, experiencedata.FieldValueNumber)
	}
	if m.FieldCleared(experiencedata.FieldValueBoolean) {
		fields = append(fields, experiencedata.FieldValueBoolean)
	}
	if m.FieldCleared(experiencedata.FieldValueDate) {
		fields = append(fields, experiencedata.FieldValueDate)
	}
	if m.FieldCleared(experiencedata.FieldValueJSON) {
		fields = append(fields, experiencedata.FieldValueJSON)
	}
	if m.FieldCleared(experiencedata.FieldMetadata) {
		fields = append(fields, experiencedata.FieldMetadata)
	}
	if m.FieldCleared(experiencedata.FieldLanguage) {
		fields = append(fields, experiencedata.FieldLanguage)
	}
	if m.FieldCleared(experiencedata.FieldSentiment) {
		fields = append(fields, experiencedata.FieldSentiment)
	}
	if m.FieldCleared(experiencedata.FieldSentimentScore) {
		fields = append(fields, experiencedata.FieldSentimentScore)
	}
	if m.FieldCleared(experiencedata.FieldEmotion) {
		fields = append(fields, experiencedata.FieldEmotion)
	}
	if m.FieldCleared(experiencedata.FieldTopics) {
		fields = append(fields, experiencedata.FieldTopics)
	}
	if m.FieldCleared(experiencedata.FieldUserIdentifier) {
		fields = append(fields, experiencedata.FieldUserIdentifier)
	}
	if m.FieldCleared(experiencedata.FieldEmbedding) {
		fields = append(fields, experiencedata.FieldEmbedding)
	}
	if m.FieldCleared(experiencedata.FieldEmbeddingModel) {
		fields = append(fields, experiencedata.FieldEmbeddingModel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExperienceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExperienceDataMutation) ClearField(name string) error {
	switch name {
	case experiencedata.FieldSourceID:
		m.ClearSourceID()
		return nil
	case experiencedata.FieldSourceName:
		m.ClearSourceName()
		return nil
	case experiencedata.FieldFieldLabel:
		m.ClearFieldLabel()
		return nil
	case experiencedata.FieldValueText:
		m.ClearValueText()
		return nil
	case experiencedata.FieldValueNumber:
		m.ClearValueNumber()
		return nil
	case experiencedata.FieldValueBoolean:
		m.ClearValueBoolean()
		return nil
	case experiencedata.FieldValueDate:
		m.ClearValueDate()
		return nil
	case experiencedata.FieldValueJSON:
		m.ClearValueJSON()
		return nil
	case experiencedata.FieldMetadata:
		m.ClearMetadata()
		return nil
	case experiencedata.FieldLanguage:
		m.ClearLanguage()
		return nil
	case experiencedata.FieldSentiment:
		m.ClearSentiment()
		return nil
	case experiencedata.FieldSentimentScore:
		m.ClearSentimentScore()
		return nil
	case experiencedata.FieldEmotion:
		m.ClearEmotion()
		return nil
	case experiencedata.FieldTopics:
		m.ClearTopics()
		return nil
	case experiencedata.FieldUserIdentifier:
		m.ClearUserIdentifier()
		return nil
	case experiencedata.FieldEmbedding:
		m.ClearEmbedding()
		return nil
	case experiencedata.FieldEmbeddingModel:
		m.ClearEmbeddingModel()
		return nil
	}
	return fmt.Errorf("unknown ExperienceData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExperienceDataMutation) ResetField(name string) error {
	switch name {
	case experiencedata.FieldCollectedAt:
		m.ResetCollectedAt()
		return nil
	case experiencedata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case experiencedata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case experiencedata.FieldSourceType:
		m.ResetSourceType()
		return nil
	case experiencedata.FieldSourceID:
		m.ResetSourceID()
		return nil
	case experiencedata.FieldSourceName:
		m.ResetSourceName()
		return nil
	case experiencedata.FieldFieldID:
		m.ResetFieldID()
		return nil
	case experiencedata.FieldFieldLabel:
		m.ResetFieldLabel()
		return nil
	case experiencedata.FieldFieldType:
		m.ResetFieldType()
		return nil
	case experiencedata.FieldValueText:
		m.ResetValueText()
		return nil
	case experiencedata.FieldValueNumber:
		m.ResetValueNumber()
		return nil
	case experiencedata.FieldValueBoolean:
		m.ResetValueBoolean()
		return nil
	case experiencedata.FieldValueDate:
		m.ResetValueDate()
		return nil
	case experiencedata.FieldValueJSON:
		m.ResetValueJSON()
		return nil
	case experiencedata.FieldMetadata:
		m.ResetMetadata()
		return nil
	case experiencedata.FieldLanguage:
		m.ResetLanguage()
		return nil
	case experiencedata.FieldSentiment:
		m.ResetSentiment()
		return nil
	case experiencedata.FieldSentimentScore:
		m.ResetSentimentScore()
		return nil
	case experiencedata.FieldEmotion:
		m.ResetEmotion()
		return nil
	case experiencedata.FieldTopics:
		m.ResetTopics()
		return nil
	case experiencedata.FieldUserIdentifier:
		m.ResetUserIdentifier()
		return nil
	case experiencedata.FieldEmbedding:
		m.ResetEmbedding()
		return nil
	case experiencedata.FieldEmbeddingModel:
		m.ResetEmbeddingModel()
		return nil
	}
	return fmt.Errorf("unknown ExperienceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExperienceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExperienceDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExperienceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExperienceDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExperienceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExperienceDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExperienceDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExperienceData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExperienceDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExperienceData edge %s", name)
}
