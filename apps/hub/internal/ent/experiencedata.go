// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/formbricks/formbricks-rewrite/apps/hub/internal/ent/experiencedata"
	"github.com/google/uuid"
	pgvector "github.com/pgvector/pgvector-go"
)

// ExperienceData is the model entity for the ExperienceData schema.
type ExperienceData struct {
	config `json:"-"`
	// ID of the ent.
	// UUIDv7 primary key (time-ordered)
	ID uuid.UUID `json:"id,omitempty"`
	// When the feedback was collected
	CollectedAt time.Time `json:"collected_at,omitempty"`
	// When this record was created in the database
	CreatedAt time.Time `json:"created_at,omitempty"`
	// When this record was last updated
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Type of feedback source (e.g., survey, review, feedback_form, support, social)
	SourceType string `json:"source_type,omitempty"`
	// Reference to survey/form/ticket ID
	SourceID string `json:"source_id,omitempty"`
	// Human-readable name (e.g., 'Q1 NPS Survey')
	SourceName string `json:"source_name,omitempty"`
	// Identifier for the question/field being answered
	FieldID string `json:"field_id,omitempty"`
	// The actual question text (e.g., 'How satisfied are you?')
	FieldLabel string `json:"field_label,omitempty"`
	// Type of field: text (enrichable), categorical, nps, csat, rating, number, boolean, date
	FieldType string `json:"field_type,omitempty"`
	// For open-ended text responses
	ValueText *string `json:"value_text,omitempty"`
	// For ratings, NPS scores, numeric responses
	ValueNumber *float64 `json:"value_number,omitempty"`
	// For yes/no questions
	ValueBoolean *bool `json:"value_boolean,omitempty"`
	// For date responses
	ValueDate *time.Time `json:"value_date,omitempty"`
	// For complex responses like multiple choice arrays
	ValueJSON map[string]interface{} `json:"value_json,omitempty"`
	// User agent, device, location, referrer, tags, custom fields, etc.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// ISO language code (e.g., 'en', 'de')
	Language string `json:"language,omitempty"`
	// AI-detected sentiment (positive, negative, neutral)
	Sentiment *string `json:"sentiment,omitempty"`
	// Sentiment score from -1 (negative) to +1 (positive)
	SentimentScore *float64 `json:"sentiment_score,omitempty"`
	// AI-detected emotion (joy, frustration, anger, etc.)
	Emotion *string `json:"emotion,omitempty"`
	// AI-extracted topics/themes from text
	Topics []string `json:"topics,omitempty"`
	// Anonymous ID or email hash for grouping responses
	UserIdentifier string `json:"user_identifier,omitempty"`
	// OpenAI embedding vector for semantic search (1536 dimensions for text-embedding-3-small)
	Embedding *pgvector.Vector `json:"embedding,omitempty"`
	// Name of the embedding model used (e.g., text-embedding-3-small)
	EmbeddingModel *string `json:"embedding_model,omitempty"`
	selectValues   sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ExperienceData) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case experiencedata.FieldEmbedding:
			values[i] = &sql.NullScanner{S: new(pgvector.Vector)}
		case experiencedata.FieldValueJSON, experiencedata.FieldMetadata, experiencedata.FieldTopics:
			values[i] = new([]byte)
		case experiencedata.FieldValueBoolean:
			values[i] = new(sql.NullBool)
		case experiencedata.FieldValueNumber, experiencedata.FieldSentimentScore:
			values[i] = new(sql.NullFloat64)
		case experiencedata.FieldSourceType, experiencedata.FieldSourceID, experiencedata.FieldSourceName, experiencedata.FieldFieldID, experiencedata.FieldFieldLabel, experiencedata.FieldFieldType, experiencedata.FieldValueText, experiencedata.FieldLanguage, experiencedata.FieldSentiment, experiencedata.FieldEmotion, experiencedata.FieldUserIdentifier, experiencedata.FieldEmbeddingModel:
			values[i] = new(sql.NullString)
		case experiencedata.FieldCollectedAt, experiencedata.FieldCreatedAt, experiencedata.FieldUpdatedAt, experiencedata.FieldValueDate:
			values[i] = new(sql.NullTime)
		case experiencedata.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ExperienceData fields.
func (ed *ExperienceData) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case experiencedata.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				ed.ID = *value
			}
		case experiencedata.FieldCollectedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field collected_at", values[i])
			} else if value.Valid {
				ed.CollectedAt = value.Time
			}
		case experiencedata.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ed.CreatedAt = value.Time
			}
		case experiencedata.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ed.UpdatedAt = value.Time
			}
		case experiencedata.FieldSourceType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_type", values[i])
			} else if value.Valid {
				ed.SourceType = value.String
			}
		case experiencedata.FieldSourceID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_id", values[i])
			} else if value.Valid {
				ed.SourceID = value.String
			}
		case experiencedata.FieldSourceName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_name", values[i])
			} else if value.Valid {
				ed.SourceName = value.String
			}
		case experiencedata.FieldFieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field field_id", values[i])
			} else if value.Valid {
				ed.FieldID = value.String
			}
		case experiencedata.FieldFieldLabel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field field_label", values[i])
			} else if value.Valid {
				ed.FieldLabel = value.String
			}
		case experiencedata.FieldFieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field field_type", values[i])
			} else if value.Valid {
				ed.FieldType = value.String
			}
		case experiencedata.FieldValueText:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field value_text", values[i])
			} else if value.Valid {
				ed.ValueText = new(string)
				*ed.ValueText = value.String
			}
		case experiencedata.FieldValueNumber:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field value_number", values[i])
			} else if value.Valid {
				ed.ValueNumber = new(float64)
				*ed.ValueNumber = value.Float64
			}
		case experiencedata.FieldValueBoolean:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field value_boolean", values[i])
			} else if value.Valid {
				ed.ValueBoolean = new(bool)
				*ed.ValueBoolean = value.Bool
			}
		case experiencedata.FieldValueDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field value_date", values[i])
			} else if value.Valid {
				ed.ValueDate = new(time.Time)
				*ed.ValueDate = value.Time
			}
		case experiencedata.FieldValueJSON:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field value_json", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ed.ValueJSON); err != nil {
					return fmt.Errorf("unmarshal field value_json: %w", err)
				}
			}
		case experiencedata.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ed.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		case experiencedata.FieldLanguage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language", values[i])
			} else if value.Valid {
				ed.Language = value.String
			}
		case experiencedata.FieldSentiment:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sentiment", values[i])
			} else if value.Valid {
				ed.Sentiment = new(string)
				*ed.Sentiment = value.String
			}
		case experiencedata.FieldSentimentScore:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field sentiment_score", values[i])
			} else if value.Valid {
				ed.SentimentScore = new(float64)
				*ed.SentimentScore = value.Float64
			}
		case experiencedata.FieldEmotion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field emotion", values[i])
			} else if value.Valid {
				ed.Emotion = new(string)
				*ed.Emotion = value.String
			}
		case experiencedata.FieldTopics:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field topics", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ed.Topics); err != nil {
					return fmt.Errorf("unmarshal field topics: %w", err)
				}
			}
		case experiencedata.FieldUserIdentifier:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_identifier", values[i])
			} else if value.Valid {
				ed.UserIdentifier = value.String
			}
		case experiencedata.FieldEmbedding:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field embedding", values[i])
			} else if value.Valid {
				ed.Embedding = new(pgvector.Vector)
				*ed.Embedding = *value.S.(*pgvector.Vector)
			}
		case experiencedata.FieldEmbeddingModel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field embedding_model", values[i])
			} else if value.Valid {
				ed.EmbeddingModel = new(string)
				*ed.EmbeddingModel = value.String
			}
		default:
			ed.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the ExperienceData.
// This includes values selected through modifiers, order, etc.
func (ed *ExperienceData) Value(name string) (ent.Value, error) {
	return ed.selectValues.Get(name)
}

// Update returns a builder for updating this ExperienceData.
// Note that you need to call ExperienceData.Unwrap() before calling this method if this ExperienceData
// was returned from a transaction, and the transaction was committed or rolled back.
func (ed *ExperienceData) Update() *ExperienceDataUpdateOne {
	return NewExperienceDataClient(ed.config).UpdateOne(ed)
}

// Unwrap unwraps the ExperienceData entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ed *ExperienceData) Unwrap() *ExperienceData {
	_tx, ok := ed.config.driver.(*txDriver)
	if !ok {
		panic("ent: ExperienceData is not a transactional entity")
	}
	ed.config.driver = _tx.drv
	return ed
}

// String implements the fmt.Stringer.
func (ed *ExperienceData) String() string {
	var builder strings.Builder
	builder.WriteString("ExperienceData(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ed.ID))
	builder.WriteString("collected_at=")
	builder.WriteString(ed.CollectedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(ed.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ed.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("source_type=")
	builder.WriteString(ed.SourceType)
	builder.WriteString(", ")
	builder.WriteString("source_id=")
	builder.WriteString(ed.SourceID)
	builder.WriteString(", ")
	builder.WriteString("source_name=")
	builder.WriteString(ed.SourceName)
	builder.WriteString(", ")
	builder.WriteString("field_id=")
	builder.WriteString(ed.FieldID)
	builder.WriteString(", ")
	builder.WriteString("field_label=")
	builder.WriteString(ed.FieldLabel)
	builder.WriteString(", ")
	builder.WriteString("field_type=")
	builder.WriteString(ed.FieldType)
	builder.WriteString(", ")
	if v := ed.ValueText; v != nil {
		builder.WriteString("value_text=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := ed.ValueNumber; v != nil {
		builder.WriteString("value_number=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := ed.ValueBoolean; v != nil {
		builder.WriteString("value_boolean=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := ed.ValueDate; v != nil {
		builder.WriteString("value_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("value_json=")
	builder.WriteString(fmt.Sprintf("%v", ed.ValueJSON))
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", ed.Metadata))
	builder.WriteString(", ")
	builder.WriteString("language=")
	builder.WriteString(ed.Language)
	builder.WriteString(", ")
	if v := ed.Sentiment; v != nil {
		builder.WriteString("sentiment=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := ed.SentimentScore; v != nil {
		builder.WriteString("sentiment_score=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := ed.Emotion; v != nil {
		builder.WriteString("emotion=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("topics=")
	builder.WriteString(fmt.Sprintf("%v", ed.Topics))
	builder.WriteString(", ")
	builder.WriteString("user_identifier=")
	builder.WriteString(ed.UserIdentifier)
	builder.WriteString(", ")
	if v := ed.Embedding; v != nil {
		builder.WriteString("embedding=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := ed.EmbeddingModel; v != nil {
		builder.WriteString("embedding_model=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// ExperienceDataSlice is a parsable slice of ExperienceData.
type ExperienceDataSlice []*ExperienceData
