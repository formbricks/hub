---
sidebar_position: 2
---

# Architecture Reference

Technical reference for contributors and those interested in Store's internal design.

:::info Audience
This page is for **contributors** and **advanced users** who want to understand Store's internals. If you're just using Store, see the [Quick Start Guide](../quickstart) instead.
:::

## Technology Stack

- **Language:** Go 1.22+
- **Web Framework:** Huma v2 (OpenAPI-first) + Chi router
- **ORM:** Ent (type-safe, code generation)
- **Database:** PostgreSQL 18
- **Documentation:** OpenAPI 3.1 + Scalar
- **Testing:** Go's built-in testing + testcontainers-go
- **License:** Apache 2.0

## Project Structure

```
apps/store/
├── cmd/
│   └── store/
│       └── main.go              # Entry point, CLI setup
├── internal/
│   ├── api/
│   │   ├── server.go            # HTTP server, Huma setup
│   │   ├── experiences.go       # CRUD handlers
│   │   └── types.go             # API request/response types
│   ├── config/
│   │   └── config.go            # Configuration management
│   ├── ent/
│   │   ├── schema/
│   │   │   └── experiencedata.go  # Ent schema definition
│   │   └── [generated files]       # Auto-generated by Ent
│   ├── middleware/
│   │   ├── auth.go              # API key authentication
│   │   ├── logging.go           # Structured logging
│   │   └── middleware.go        # Shared middleware
│   ├── models/
│   │   └── experience.go        # Domain models (business logic)
│   └── webhook/
│       ├── dispatcher.go        # Webhook delivery
│       └── dispatcher_test.go   # Webhook tests
├── docker-compose.yml           # Local PostgreSQL
├── Dockerfile                   # Production image
├── Makefile                     # Dev commands
├── go.mod                       # Go dependencies
└── README.md                    # Developer docs
```

## Architecture Layers

### 1. Entry Point (`cmd/store/main.go`)

- Parses CLI arguments and environment variables using Huma CLI
- Initializes logger based on `SERVICE_LOG_LEVEL`
- Connects to PostgreSQL via Ent
- Runs database migrations automatically
- Creates and starts HTTP server

### 2. API Layer (`internal/api/`)

**Responsibilities:**
- HTTP request handling
- Request validation
- Response formatting
- OpenAPI documentation generation

**Key Components:**
- `server.go` - Huma API setup, Chi router, middleware registration
- `experiences.go` - CRUD operation handlers
- `types.go` - API-specific DTOs (Data Transfer Objects)

### 3. Middleware (`internal/middleware/`)

**Chain:**
1. Chi middleware (RequestID, RealIP, Recoverer)
2. Custom logging middleware (structured logs)
3. Optional API key auth middleware

**Execution order:**
```
Request → Chi middleware → Huma API → Custom middleware → Handler → Response
```

### 4. Domain Models (`internal/models/`)

**Purpose:** Separate API concerns from business logic.

**Flow:**
```
API Request → API DTO → Domain Model → Ent Entity → Database
                ↓                           ↑
            Validation              Database Query
```

**Why?**
- Clean separation of concerns
- Easy to add business logic (e.g., calculated fields)
- API changes don't directly affect database schema

### 5. ORM Layer (`internal/ent/`)

**Ent's role:**
- Type-safe database queries
- Auto-generate CRUD methods
- Handle migrations automatically
- Provide graph traversal (for future relations)

**Code generation workflow:**
1. Define schema in `internal/ent/schema/experiencedata.go`
2. Run `make ent-gen` to generate code
3. Generated files in `internal/ent/` (committed to Git)

### 6. Webhook System (`internal/webhook/`)

**Design:**
- Async dispatch (doesn't block API responses)
- Retry logic with exponential backoff
- Concurrent delivery to multiple URLs

**Delivery guarantees:**
- At-least-once delivery (with retries)
- 5-second timeout per attempt
- 3 total attempts (1 initial + 2 retries)

## Data Flow

### Create Experience

```
1. POST /v1/experiences
   ↓
2. Huma validates request against OpenAPI spec
   ↓
3. Handler receives CreateExperienceInput
   ↓
4. Convert API DTO to Ent builder
   ↓
5. Save to PostgreSQL via Ent
   ↓
6. Convert Ent entity → Domain model → API response
   ↓
7. Dispatch webhook asynchronously
   ↓
8. Return 201 Created with experience data
```

### List Experiences with Filters

```
1. GET /v1/experiences?source_type=survey&limit=50
   ↓
2. Huma parses and validates query parameters
   ↓
3. Handler builds Ent query with filters
   ↓
4. Execute query with pagination
   ↓
5. Get total count (separate query)
   ↓
6. Convert results to API format
   ↓
7. Return paginated response
```

## Database Schema

### ExperienceData Table

```sql
CREATE TABLE experience_data (
  -- Primary key
  id UUID PRIMARY KEY DEFAULT gen_uuidv7(),
  
  -- Timestamps
  collected_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  
  -- Source information
  source_type VARCHAR NOT NULL,
  source_id VARCHAR,
  source_name VARCHAR,
  
  -- Field information
  field_id VARCHAR NOT NULL,
  field_label VARCHAR,
  field_type VARCHAR NOT NULL,
  
  -- Response values
  value_text TEXT,
  value_number DOUBLE PRECISION,
  value_boolean BOOLEAN,
  value_date TIMESTAMP,
  value_json JSONB,
  
  -- Metadata
  metadata JSONB,
  language VARCHAR(10),
  user_identifier VARCHAR
);

-- Indexes for analytics
CREATE INDEX idx_source_type ON experience_data(source_type);
CREATE INDEX idx_source_id ON experience_data(source_id);
CREATE INDEX idx_collected_at ON experience_data(collected_at);
CREATE INDEX idx_field_type ON experience_data(field_type);
CREATE INDEX idx_value_number ON experience_data(value_number);
CREATE INDEX idx_user_identifier ON experience_data(user_identifier);

-- Composite indexes
CREATE INDEX idx_source_collected ON experience_data(source_type, source_id, collected_at);
CREATE INDEX idx_field_collected ON experience_data(field_type, collected_at);
```

## Configuration Management

### Huma CLI Integration

Store uses Huma's built-in CLI with the `SERVICE_` prefix convention:

```go
type Options struct {
    Port        int    `help:"Port to listen on" default:"8080"`
    DatabaseURL string `help:"PostgreSQL connection URL" required:"true"`
    APIKey      string `help:"Optional API key" default:""`
    // ...
}
```

**Environment variable mapping:**
- `SERVICE_PORT` → `Options.Port`
- `SERVICE_DATABASE_URL` → `Options.DatabaseURL`
- `SERVICE_API_KEY` → `Options.APIKey`

## Testing Strategy

### Unit Tests

Test individual functions:

```go
// internal/webhook/dispatcher_test.go
func TestDispatcher_Dispatch(t *testing.T) {
    // Test webhook delivery logic
}
```

### Integration Tests

Test API endpoints with real database:

```go
// internal/api/experiences_test.go
func TestCreateExperience(t *testing.T) {
    // Uses testcontainers-go for real PostgreSQL
    // Tests full request → response flow
}
```

**Why testcontainers?**
- ✅ Test against real PostgreSQL (production parity)
- ✅ Automatic cleanup after tests
- ✅ CI/CD friendly (GitHub Actions)
- ✅ No mocking database behavior

## Development Workflow

### Making Changes

1. **Edit code** in `internal/`
2. **Hot reload** via Air (automatic restart)
3. **Test locally** against PostgreSQL in Docker
4. **Run tests**: `make test`
5. **Check types**: `go build ./cmd/store`

### Adding a New Field to ExperienceData

1. Edit `internal/ent/schema/experiencedata.go`
2. Run `make ent-gen` to regenerate code
3. Restart service (migrations run automatically)
4. Update API types in `internal/api/types.go`
5. Update handlers in `internal/api/experiences.go`
6. Update tests

### Adding a New Endpoint

1. Define operation in `internal/api/experiences.go`:
   ```go
   huma.Register(api, huma.Operation{
       OperationID: "my-operation",
       Method:      "GET",
       Path:        "/v1/my-endpoint",
       // ...
   }, handlerFunc)
   ```
2. Create input/output types in `internal/api/types.go`
3. Implement handler logic
4. Write tests in `internal/api/*_test.go`
5. OpenAPI docs auto-generate

## Performance Considerations

### Database Indexes

Pre-created indexes optimize common queries:
- Time-range queries (`collected_at`)
- Filtering by source (`source_type`, `source_id`)
- Numeric aggregations (`value_number`)

### Connection Pooling

PostgreSQL driver handles connection pooling automatically. Configure via connection string:

```
?pool_max_conns=20&pool_min_conns=5
```

### Webhook Async Delivery

Webhooks don't block API responses. They're dispatched in goroutines with timeout and retry logic.

## Security

### API Key Authentication

Simple shared-secret authentication via `X-API-Key` header. For production, consider:
- API Gateway (AWS API Gateway, Kong, Traefik)
- OAuth 2.0 / JWT
- mTLS for service-to-service

### Database Security

- Use parameterized queries (Ent does this automatically)
- Never log sensitive data
- Use `sslmode=require` in production

## Observability

### Structured Logging

All logs use `slog` (Go 1.21+):

```json
{
  "time": "2025-10-15T12:34:56Z",
  "level": "INFO",
  "msg": "experience created",
  "id": "01932c8a-8b9e-7000-8000-000000000001",
  "source_type": "survey"
}
```

### Health Checks

- `GET /health` - Always returns `{"status":"ok"}`
- Database connectivity checked on startup only

## Contributing

See [CONTRIBUTING.md](https://github.com/formbricks/formbricks-rewrite/blob/main/CONTRIBUTING.md) for:
- Code style guidelines
- Pull request process
- Testing requirements
- Community guidelines

## Next Steps for Contributors

- **Set up locally**: [Quick Start Guide](../quickstart)
- **Explore codebase**: `apps/store/internal/`
- **Run tests**: `make test`
- **GitHub Discussions**: [Ask questions](https://github.com/formbricks/store/discussions)

